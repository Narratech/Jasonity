// Copyright (C) 2003  Rafael H. Bordini, Jomi F. Hubner, et al.
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//----------------------------------------------------------------------------


options {
   FORCE_LA_CHECK=true;
   STATIC=false;
   IGNORE_CASE=false;
   UNICODE_INPUT=true;
   CODE_GENERATOR="org.javacc.csharp.CodeGenerator";
   NAMESPACE="Assets.Code.Logic.Parser";
}

PARSER_BEGIN(as2j)

PARSER_END(as2j)

SKIP : {
 " "
|  "\t"
|  "\n"
|  "\r"
|  <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")?>
|  <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}

// Note: i do not why, but vars must be defined before TK_BEGIN and END
TOKEN : {
  <VAR : (<UP_LETTER> (<CHAR>)*) >
}

TOKEN : {
// Predefined
  <TK_TRUE:   "true">
| <TK_FALSE:  "false">
| <TK_NOT:    "not">
| <TK_NEG:    "~">
| <TK_INTDIV: "div">
| <TK_INTMOD: "mod">
| <TK_BEGIN:  "begin" >
| <TK_END:    "end" >
| <TK_LABEL_AT: "@"> // special chars

| <TK_IF:     "if" >
| <TK_ELSE:   "else" >
| <TK_ELIF:   "elif" >
| <TK_FOR:    "for" >
| <TK_WHILE:  "while" >

| <TK_PAND:  "|&|" >
| <TK_POR:   "|||" >

// Numbers
|  <NUMBER: ["0"-"9"] (["0"-"9"])*
          | (["0"-"9"])* "." (["0"-"9"])+ (["e","E"] (["+","-"])? (["0"-"9"])+)?
          | (["0"-"9"])+ (["e","E"] (["+","-"])? (["0"-"9"])+) >

// Strings
|  <STRING: "\"" ( ~["\"","\\","\n","\r"]
                 | "\\" ( ["n","t","b","r","f","\\","\'","\""]
                        | ["0"-"7"] (["0"-"7"])?
                        | ["0"-"3"] ["0"-"7"] ["0"-"7"]))* "\"">

// Identifiers
|  <ATOM      : (<LC_LETTER> | "." <CHAR>) (<CHAR> | "." <CHAR>)*
                | ("'" (~["'"])* "'" ) >
                { if (image.charAt(0) == '\'') matchedToken.image = image.substring(1, lengthOfMatch-1); }
|  <UNNAMEDVARID: ("_" (<DIGIT>)+ (<CHAR>)*) >
|  <UNNAMEDVAR: ("_" (<CHAR>)*) >
|  <CHAR      : (<LETTER> | <DIGIT> | "_")>
|  <LETTER    : ( <LC_LETTER> | <UP_LETTER> )>
|  <LC_LETTER : ["a"-"z"]>
|  <UP_LETTER : ["A"-"Z"]>
|  <DIGIT     : ["0"-"9"]>
}

/* AgentSpeak Grammar */

/*   agent ::= bels goals plans

     returns true if achieved the end of file
     returns false if achieved a "{ end }" directive
*/
bool agent(Agent.Agent a):
{ 
	Literal b;
    Literal g;
    Plan    p;
    curAg = a;
    asSource = a.GetASLSrc();
    bool endDir = false;
}

{
  ( endDir = directive(a)     { if (endDir) return false; }  )*

  // beliefs
  ( b = belief()              { if (a != null) a.AddInitialBel(b); }
    ( endDir = directive(a)   { if (endDir) return false; }  )*
  )*

  // initial goals
  ( g = initial_goal()        { if (a != null) a.AddInitialGoal(g); }
    ( endDir = directive(a)   { if (endDir) return false; }  )*
  )*

  // plans and rules
  ( p = plan() 
  { 
  	if (a != null) 
  	{
       p.SetSource(asSource);
       a.GetPL().Add(p);
    }
  }
    ( b = belief()            
    	{ 
    		if (a != null) {
              if (b.IsRule()) {
                  a.AddInitialBel(b);
              } else {
              	  /*CAMBIAR: No se puede usar throw en c#
                  throw new ParseException(getSourceRef(b)+" The belief '"+b+"' is not in the begin of the source code!");*/
              }
            }
        }
    )*
    ( endDir = directive(a)   { if (endDir) return false; }  )*

  )*

  <EOF>
      {
        if (a != null) parsedFiles.Add(a.GetASLSrc());
        return true;
      }
}

/* Directive

   returns true if the directive is "{ end }", false otherwise
*/
bool directive(Agent.Agent outerAg):
{
    Pred dir = null;
    Agent.Agent resultOfDirective = null;
    Agent.Agent bakAg = curAg;
    bool isEOF = false;
    Atom oldNS = null;
}

{
  "{"
  ( LOOKAHEAD(4)
    <TK_BEGIN> dir = pred() "}"
    { 
    	Agent innerAg = new Agent(); 
    	innerAg.InitAg();
        dir = new Pred(@namespace, dir);
        /*HACER: Clase directive
        Directive d = directiveProcessor.GetInstance(dir);
        d.begin(dir,this);*/
    }
     	
    isEOF = agent(innerAg)
        { 
        	if (isEOF)
                /* CAMBIAR: No se pueden usar throw en c#
                throw new ParseException(getSourceRef(dir)+" The directive '{ begin "+dir+"}' does not end with '{ end }'.");*/

            /*HACER: Clase directive
            resultOfDirective = d.process(dir, outerAg, innerAg);
            d.end(dir,this);*/
        }
  |
    dir = pred() "}"
    { 
    	if (dir.toString().equals("end"))
            return true;

        dir = new Pred(namespace, dir);
        /*HACER: Clase directive
        Directive d = directiveProcessor.getInstance(dir);
        d.begin(dir, this); // to declare the namespace as local
        resultOfDirective = d.process(dir, outerAg, null);
        d.end(dir, this);*/
    }
  )

    { 
    	/*HACER: Clase directive
    	if (resultOfDirective != null && outerAg != null) {
			// import bels, plans and initial goals from agent resultOfDirective
			outerAg.importComponents(resultOfDirective);
        }*/
        curAg = bakAg;
        return false;
    }
}


/* Beliefs & Rules */
Literal belief() : { Literal h; object t; }
{
    h=literal()              
    { 
    	if (h.IsVar()) {
            
            /*CAMBIAR: No se pueden usar throw en c#                      
            throw new ParseException(getSourceRef(h)+" variables cannot be beliefs!");*/
        }
    }

    [
      ":-" t = log_expr()    {
      		h = new Rule(h,(LogicalFormula)t);
        }
    ]
    "." { return h; }
}


/* Initial goals */
Literal initial_goal() : { Literal g; }
{
  "!" g=literal() "."    
  { 
  	if (g.IsVar()) {
        /*CAMBIAR: No se puede usar throw en c#
        throw new ParseException(getSourceRef(g)+". a variable cannot be a goal!");*/
    }
    return g;
  }
}


/* Plan */
Plan plan() :         
{ 
	Token k;
    Pred L = null; 
    Literal L2;
    Trigger T;
    object C = null;
    PlanBody B = null;
    int start = -1, end;
}

{
    [ k = <TK_LABEL_AT> L2=literal()  { start = k.beginLine; L = new Pred(L2); }   ] // use literal to allow namespace
    T=trigger()
    [ k = ":"  C = log_expr()    { if (start == -1) start = k.beginLine; } ]
    [ k = "<-" B = plan_body()   { if (start == -1) start = k.beginLine; } ]
    k = "."                      { if (start == -1) start = k.beginLine; }
    
    { 
    	end = k.beginLine;
        InternalActionLiteral ial = null;
        try { ial = CheckInternalActionsInContext((LogicalFormula)c, curAg); } catch (Exception e) {}

        if (ial != null)
            /*CAMBIAR: No se pueden usar throw en c#
            throw new ParseException(getSourceRef(ial)+" The internal action '"+ial+"' can not be used in plan's context!");*/

        if (B != null && B.GetBodyTerm().Equals(Literal.LTrue))
            B = (PlanBody)B.GetBodyNext();
        Plan p = new Plan(L,T,(LogicalFormula)C, B);
        p.SetSrcInfo(new SourceInfo(asSource,start,end));
        return p;
    }
}

/* Trigger */
Trigger trigger() :
{
	TEOperator teOp;
	TEType teType = TEType.belief;
 	Literal F;
}

{
  ( "+"        { teOp = TEOperator.add; }
  | "-"        { teOp = TEOperator.del; }
  | "^"        { teOp = TEOperator.goalState; }
  )

  [ ( "!"      { teType = TEType.achieve; }
    | "?"      { teType = TEType.test; }
    )
  ]

  F=literal()  { return new Trigger(teOp,teType,F.forceFullLiteralImpl()); }
}


/* Plan body */
PlanBody plan_body() :      { Object F; PlanBody R = null; }
{
	F = plan_body_term()

	[ ";" ][ R = plan_body() ]

    { 
    	if (R != null) {
            ((PlanBody)F).SetBodyNext( R );
        }

        return (PlanBody)F;
    }
}

PlanBody plan_body_term() : { Object F; PlanBody R = null; }
{
	F = plan_body_factor()

	[ <TK_POR> R = plan_body_term() ]

    {
       if (R == null)
           return (PlanBody)F;
        try {
          Structure s = ASSyntax.createStructure(".fork", jason.stdlib.fork.aOr, (Term)F);
          
          if (R.ToString().StartsWith(".fork(or,")) {
             // if R is another fork or, put they args into this fork
             InternalActionLiteral ial = (InternalActionLiteral)R.GetBodyTerm();

             //HACER: clase fork de stdlib
             if (ial.GetIA(curAg).GetType == typeof (Fork)) {
                for (int i=1; i<ial.GetArity(); i++) {
                   s.AddTerm(ial.GetTerm(i));
                }
             } 
          } 
          else {
             s.AddTerm(R);
          }

          Literal stmtLiteral = new InternalActionLiteral(s, curAg);
          stmtLiteral.SetSrcInfo(((Term)F).GetSrcInfo());
          return new PlanBodyImpl(BodyType.internalAction, stmtLiteral);
       } catch (Exception e) {
            e.printStackTrace();
       }
    }
}

PlanBody plan_body_factor() : { object F; PlanBody R = null; } // bool hasPV = false; bool isControl = true; }
{

	( F = stmtIF()
	| F = stmtFOR()
	| F = stmtWHILE()
	| F = body_formula()                                  
	{ //isControl = false;
        /*CAMBIAR: No se pueden usar throw en c#
        if (!(F instanceof PlanBody)) throw new ParseException(getSourceRef(F)+" "+F+" is not a body literal!");*/  
    }
	)

[ <TK_PAND> R = plan_body_factor() ]
	{
       if (R == null)
          return (PlanBody)F;
       try {
          Structure s = ASSyntax.CreateStructure(".fork", jason.stdlib.fork.aAnd, (Term)F);
          if (R.ToString().StartsWith(".fork(and,")) {
             // if R is another fork and, put they args into this fork
             InternalActionLiteral ial = (InternalActionLiteral)R.GetBodyTerm();
             if ((ial.GetIA(curAg)).GetType == typeof (jason.stdlib.fork)) {
                for (int i=1; i<ial.GetArity(); i++) {
                   s.AddTerm(ial.GetTerm(i));
                }
             }
          } else {
             s.AddTerm(R);
          }
          Literal stmtLiteral = new InternalActionLiteral(s, curAg);
          stmtLiteral.SetSrcInfo( ((Term)F).GetSrcInfo() );
          return new PlanBodyImpl(BodyType.internalAction, stmtLiteral);
       } catch (Exception e) {
          e.printStackTrace();
       }
    }
}


PlanBody stmtIF() :    { PlanBody B; }
{
   <TK_IF>
   B = stmtIFCommon()
   { return B; }
}

PlanBody stmtIFCommon() :    { object B; Term T1; Term T2 = null; Literal stmtLiteral = null; }
{
   "("
   B = log_expr()
   ")"
   T1 = rule_plan_term()
   [ (
     <TK_ELIF> T2 = stmtIFCommon() 
     |
     <TK_ELSE> T2 = rule_plan_term() 
     )
   ]
       { try {
            if (T1.IsRule()) {
            	/*CAMBIAR: No se puede usar throw en c#
                throw new ParseException(getSourceRef(T1)+" if requires a plan body.");*/
            }
            if (T2 == null) { 
                stmtLiteral = new InternalActionLiteral(ASSyntax.CreateStructure(".if_then_else", (Term)B, T1), curAg);
            } else if (T2 != null) { // else case
                if (T2.IsRule()) {
                  /*CAMBIAR: No se puede usar throw en c#
                  throw new ParseException(getSourceRef(T2)+" if (else) requires a plan body.");*/
                }
                stmtLiteral = new InternalActionLiteral(ASSyntax.CreateStructure(".if_then_else", (Term)B, T1, T2), curAg);
            }
            stmtLiteral.SetSrcInfo( ((Term)B).GetSrcInfo() );
            return new PlanBodyImpl(BodyType.internalAction, stmtLiteral);
         } catch (Exception e) {
            e.printStackTrace();
         }
       }
}

PlanBody stmtFOR() :   { object B; Term T1; Literal stmtLiteral; }
{
   <TK_FOR>
   "("
   B = log_expr()
   ")"
   T1 = rule_plan_term()
    { 
    	try {
            if (T1.IsRule()) {
            	/*CAMBIAR: No se puede usar throw en c#
               throw new ParseException(GetSourceRef(T1)+"for requires a plan body.");*/
            }
            stmtLiteral = new InternalActionLiteral(ASSyntax.CreateStructure(".foreach", (Term)B, T1), curAg);
            stmtLiteral.SetSrcInfo( ((Term)B).GetSrcInfo() );
            return new PlanBodyImpl(BodyType.internalAction, stmtLiteral);
    	} catch (Exception e) {
            e.printStackTrace();
    	}
    }
}

PlanBody stmtWHILE() : { object B; Term T1; Literal stmtLiteral; }
{
   <TK_WHILE>
   "("
   B = log_expr()
   ")"
   T1 = rule_plan_term()
   { 
   		try {
            if (T1.IsRule()) {
            	/*CAMBIAR: No se puede usar throw en c#
               throw new ParseException(getSourceRef(T1)+"while requires a plan body.");*/
            }
            stmtLiteral = new InternalActionLiteral(ASSyntax.CreateStructure(".loop", (Term)B, T1), curAg);
            stmtLiteral.SetSrcInfo( ((Term)B).GetSrcInfo() );
            return new PlanBodyImpl(BodyType.internalAction, stmtLiteral);
    	} catch (Exception e) {
            e.printStackTrace();
        }
    }
}


Object body_formula() :
                       { BodyType formType = BodyType.action;  Object B; }
{
   [  "!"              { formType = BodyType.achieve; }
    | "!!"             { formType = BodyType.achieveNF; }
    | "?"              { formType = BodyType.test; }
    | ( "+"            { formType = BodyType.addBel; }
        [ ( "+"        { formType = BodyType.addBelNewFocus; }
          | "<"        { formType = BodyType.addBel; }
          | ">"        { formType = BodyType.addBelEnd; }
          )
        ]
      )
    | ( "-"            { formType = BodyType.delBel; }
        ["+"           { formType = BodyType.delAddBel; }
        |
         "-"           { formType = BodyType.delBelNewFocus; }
        ]
      )
   ]

   (
      B = rule_plan_term()
    |
      B = log_expr()
   )
   { 
   		if (formType == BodyType.action && (B.GetType() ==  typeof(RelExpr)) {
        return new PlanBodyImpl(BodyType.constraint, (RelExpr)B); // constraint
        }
                         
        if (B.GetType() == typeof (Plan)) {
           	try {
	            InternalActionLiteral ia = null;
	            String ias = "";
	            if (formType == BodyType.delBel) {
	                ia = new InternalActionLiteral(ASSyntax.CreateStructure(".remove_plan", (Term)B), curAg);
	            } else if (formType == BodyType.addBel) {
	                ia = new InternalActionLiteral(ASSyntax.CreateStructure(".add_plan", (Term)B, BeliefBase.ASelf, new Atom("begin")), curAg);
	            } else if (formType == BodyType.addBelEnd) {
	                ia = new InternalActionLiteral(ASSyntax.CreateStructure(".add_plan", (Term)B, BeliefBase.ASelf, new Atom("end")), curAg);
	            } else {
	            	/*CAMBIAR: No se puede usar throw en c#
	            	throw new ParseException(getSourceRef(B)+" Wrong combination of operator "+formType+" and plan.");
	            	*/
	            }
	             return new PlanBodyImpl(BodyType.internalAction, ia);
	        } catch (Exception e) {
	             e.printStackTrace();
	        }
        }

	    if (B.GetType() == typeof (Literal)) {
	        if ( ((Literal)B).IsInternalAction() )
	           formType = BodyType.internalAction;

	        return new PlanBodyImpl(formType, (Literal)B);
	    } else {
            if (formType == BodyType.test) {
               if (B.GetType() == typeof(LogicalFormula))
                  return new PlanBodyImpl(BodyType.test, (Term)B);  // used in ?(a & b)
               else
               		/*CAMBIAR: No se puede usar throw en c#
                  throw new ParseException(getSourceRef(B)+" The argument for ? is not a logical formula.");*/
            } else {
               return B;
            }
        }
    }
}

Term rule_plan_term():       
{ 
	Trigger T = null; object C = null; PlanBody B = null, B1 = null; Plan P = null;
    bool pb = true; // pb = "only plan body"
    Pred L = null;
    Literal h = null; Object t = null;
}

{
  "{"
  [ LOOKAHEAD(4)
    [<TK_LABEL_AT> (L=pred() | L=var(Literal.DefaultNS)) { pb = false; } ]
    T = trigger()           { if (T.GetType() != TEType.belief) pb = false; }
    [ ":" C = log_expr()    { pb = false; } ]
    [( "<-"                 { pb = false; }
     | ";"                  { /*CAMBIAR: No poder usar throw if (!pb) throw new ParseException(getSourceRef(T)+" Wrong place for ';'");*/ }
     )
    ]
  ]
  [ LOOKAHEAD(150)
    h=literal()
    ":-"
    t = log_expr()
  ]
  [ B = plan_body() ]
  "}"
                         
    {   
   		if (h != null) {
            Rule r = new Rule(h,(LogicalFormula)t);
            r.SetAsTerm(true);
            return r;
        }
                             
	    // the plan body case
	    if (T != null) {
	        // handle the case of "+a1", parsed as TE, need to be changed to plan's body
	        // handle the case of "+a1; +a2", parsed as "TE; Body"
	        
	        if (pb && L == null) {
	          	if (T.IsAddition())
	             	B1 = new PlanBodyImpl(BodyType.addBel, T.GetLiteral(), true);
	          	else
	             	B1 = new PlanBodyImpl(BodyType.delBel, T.GetLiteral(), true);

	          	if (B != null)
	             	B1.SetBodyNext(B);
	        	return B1;
	        }

	        if (C == null && B == null && L == null) {
	            // handle the case of a single trigger
	            T.SetAsTriggerTerm(true);
	            return T;
	        } else {
	            // handle the case of a entire plan
	            Plan p = new Plan(L,T,(LogicalFormula)C, B);
	            p.SetSrcInfo(T.getSrcInfo());
	            p.SetAsPlanTerm(true);
	            return p;
	        }
	    }

	    // the case of a simple plan body term
	    if (B == null)
	        B = new PlanBodyImpl();
	    B.SetAsBodyTerm(true);
	    return B;
	}
}


/* Literal */
Literal literal() :
{ 
	Pred F = null; Pred V; Token k; bool type = Literal.LPos;
    Atom NS = @namespace; Token tns = null; boolean explicitAbstractNS = true; 
}

{
( (
      // namespace
    [ LOOKAHEAD(27)
        [
        (tns = <ATOM>         
        	{ 
        		if (tns.image.Equals("default"))
                    NS = Literal.DefaultNS;
                else if (tns.image.equals("this_ns"))
                    NS = thisnamespace;
                else
                    NS = new Atom(tns.image);
                explicitAbstractNS = false;
            }
         |
         	NS = var(Literal.DefaultNS)
            { 
            	if (NS.HasAnnot())
	               /*CAMBIAR: No se puede usar throw en c#
	               throw new ParseException(getSourceRef(NS)+" name space cannot have annotations.");*/
            	explicitAbstractNS = false;
            }
        )
        ]
         "::"
            { if (explicitAbstractNS)
                NS = thisnamespace;
            }
    ]

    [ <TK_NEG>              { type = Literal.LNeg; }
    ]

    (F=pred()
       | V = var(NS)          
       { 
       		VarTerm vt = (VarTerm)V;
            vt.SetNegated(type);
            return vt;
       }
    )
  )
  | k=<TK_TRUE>               { return Literal.LTrue; }
  | k=<TK_FALSE>              { return Literal.LFalse; }
)

	{
        if (ASSyntax.IsKeyword(F))
            NS = Literal.DefaultNS;
        /*HACER: Clase NameSpace
        NS = nsDirective.Map(NS);*/

        /*HACER: Clase FunctionRegister*/
        if (F.GetFunctor().IndexOf(".") >= 0) {
           if (F.HasAnnot())
           	  /*CAMBIAR: No se puede usar throw en c#
              throw new ParseException(getSourceRef(F)+" Internal actions cannot have annotations.");*/
           if (type == Literal.LNeg)
           	  /*CAMBIAR: No se puede usar throw en c#
              throw new ParseException(getSourceRef(F)+" Internal actions cannot be negated.");*/
           try {
              if (F.GetFunctor().Equals(".include")) // .include needs a namespace (see its code)
                 return new InternalActionLiteral(NS, F, curAg);
              else
                 return new InternalActionLiteral(F, curAg);
           } catch (Exception e) {
             
           }
        }

        return new LiteralImpl(NS, type, F);
    }
}

/* Annotated Formulae */
Pred pred() :          
{ 
	Token K; Pred p; List l; ListTerm lt; Term b;
    Atom ons = @namespace; @namespace = Literal.DefaultNS; // do not replace abstract namespace for terms
}

{
  (
   K=<ATOM>
   |
   K=<TK_BEGIN>
   |
   K=<TK_END>
  )
   { p = new Pred(K.image);
        p.SetSrcInfo(new SourceInfo(asSource, K.beginLine));
   }

  [
    "(" l = terms()
    ")"                { p.SetTerms(l); }
  ]
  [
    lt = list()        { p.SetAnnots(lt); }
  ]
                       { @namespace = ons;
                         return p;
                       }
}


/* List of terms */
List terms() :    { ArrayList listTerms = new ArrayList(); Term v; PlanBody o; }
{
  v=term()             { listTerms.Add(v); }
  ( "," v=term()       { listTerms.Add(v); }
  )*
                       { listTerms.TrimToSize();
                         return listTerms;
                       }
}


Term term() :          { object o; }
{
  ( o=list()
  | o=rule_plan_term()
  | o=log_expr()       // log_expr includes literals/atoms/structures
  )
                       { return ChangeToAtom(o); }
}


ListTermImpl list() :     
{ 
	ListTermImpl lt = new ListTermImpl(); ListTerm last; Token K; Term f;
    Atom ons = @namespace; @namespace = Literal.DefaultNS; // do not replace abstract namespace for terms
}

{
  "["
  [
  f=term_in_list()        { last = lt.Append(f); lt.SetSrcInfo(f.GetSrcInfo()); }
  ( "," f=term_in_list()  { last = last.Append(f); }
  )*
  [ "|"  ( K=<VAR>        { last.SetNext(new VarTerm(K.image)); }
         | K=<UNNAMEDVAR> { last.SetNext(UnnamedVar.Create(K.image)); }
         | f=list()       { last = last.Concat((ListTerm)f); }
         )
  ]
  ]
  "]"                     { @namespace = ons; return lt; }
}

// term_in_list is the same as term, but log_expr/plan_body must be enclosed by "("....")" to avoid problem with |
Term term_in_list() :     { object o; }
{
  ( o=list()
  | o=arithm_expr()
  | o=string()
  | o=rule_plan_term()
  )
                          { return ChangeToAtom(o); }
}


/* logical expression */

Object log_expr() :         { object t1, t2; }
{
   t1 = log_expr_trm()
   [  "|" t2 = log_expr()   { return new LogExpr((LogicalFormula)t1,LogicalOp.or,(LogicalFormula)t2); } ]
                            { return t1; }
}

Object log_expr_trm() :     { object t1, t2; }
{
   t1 = log_expr_factor()
[  "&" t2 = log_expr_trm()  { return new LogExpr((LogicalFormula)t1,LogicalOp.and,(LogicalFormula)t2); } ]
                            { return t1; }
}

Object log_expr_factor():
                                    { object t; }
{
(
  <TK_NOT> t = log_expr_factor()    { return new LogExpr(LogicalOp.not,(LogicalFormula)t); }
 |
  t = rel_expr()                    { return t; }
)
}


/* relational expression
   used in context, body and term

     <VAR>      [ <OPREL> <EXP> ]  --> this method returns the VarTerm
   | <LITERAL>  [ <OPREL> <EXP> ]  --> returns the Literal
   | <EXP>      [ <OPREL> <EXP> ]  --> returns the ExprTerm
*/
Object rel_expr() :
                                          {  object op1 = null;
                                             object op2 = null;
                                             RelationalOp operator = RelationalOp.none;
                                           }
{
    (   op1 = arithm_expr()
      | op1 = string()
    )

    [
       ( "<"                               { operator = RelationalOp.lt; }
       | "<="                              { operator = RelationalOp.lte; }
       | ">"                               { operator = RelationalOp.gt; }
       | ">="                              { operator = RelationalOp.gte; }
       | "=="                              { operator = RelationalOp.eq; }
       | "\\=="                            { operator = RelationalOp.dif; }
       | "="                               { operator = RelationalOp.unify; }
       | "=.."                             { operator = RelationalOp.literalBuilder; }
       )

       (   op2 = arithm_expr()
         | op2 = string()
         | op2 = list()
         | op2 = rule_plan_term()
       )

            { 
            	if ( ((Term)op1).IsInternalAction() && operator != RelationalOp.literalBuilder)
                    /*CAMBIAR: No se pueden usar throw en c# 
                    throw new ParseException(getSourceRef(op1)+" RelExpr: operand '"+op1+"' can not be an internal action.");*/
                                             
                if ( ((Term)op2).IsInternalAction() && operator != RelationalOp.literalBuilder)
                    /*CAMBIAR: No se puede usar throw en c#
                    throw new ParseException(getSourceRef(op2)+" RelExpr: operand '"+op2+"' can not be an internal action.");*/
                                             
                return new RelExpr((Term)op1, operator, (Term)op2);
            }
    ]
    { return op1; }
}


/* arithmetic expression */
Object arithm_expr() :        { object t1, t2; ArithmeticOp op; }
{
   t1 = arithm_expr_trm()     { op = ArithmeticOp.none; }
   (  ( "+"                      { op = ArithmeticOp.plus;}
      | "-"                      { op = ArithmeticOp.minus;}
      )
      t2 = arithm_expr_trm()     
      { 
      		if (!(t1.GetType() == typeof(NumberTerm))) {
                /*CAMBIAR: No se puede usar throw en c#
                throw new ParseException(getSourceRef(t1)+" ArithExpr: first operand '"+t1+"' is not numeric or variable.");*/
            }
                                   
            if (!(t2.GetType() == typeof(NumberTerm)) {
            	/*CAMBIAR: No se puede usar throw en c#
                throw new ParseException(getSourceRef(t2)+" ArithExpr: second operand '"+t2+"' is not numeric or variable.");*/
            }
            t1 = new ArithExpr((NumberTerm)t1, op, (NumberTerm)t2);
       }
   )*  { return t1; }
}

Object arithm_expr_trm() :      { object t1, t2; ArithmeticOp op; }
{
   t1 = arithm_expr_factor()    { op = ArithmeticOp.none; }
(  ( "*"                        { op = ArithmeticOp.times; }
   | "/"                        { op = ArithmeticOp.div; }
   | <TK_INTDIV>                { op = ArithmeticOp.intdiv; }
   | <TK_INTMOD>                { op = ArithmeticOp.mod; }
   )
   t2 = arithm_expr_factor()    
   { 
   		if (!(t1.GetType() == typeof(NumberTerm)) {
            /*CAMBIAR: No se puede usar throw en c#
            throw new ParseException(getSourceRef(t1)+" ArithTerm: first operand '"+t1+"' is not numeric or variable.");*/
        }
        if (!(t2.GetType() == typeof(NumberTerm)) {
        	/*CAMBIAR: No se puede usar throw en c#
            throw new ParseException(getSourceRef(t2)+" ArithTerm: second operand '"+t2+"' is not numeric or variable.");*/
        }
        t1 = new ArithExpr((NumberTerm)t1, op, (NumberTerm)t2);
    }
)*  { return t1; }
}

Object arithm_expr_factor():
                                { object t1, t2; ArithmeticOp op;}
{
   t1 = arithm_expr_simple()    { op = ArithmeticOp.none; }
[  ( "**"                       { op = ArithmeticOp.pow; }
   )
   t2 = arithm_expr_factor()    
   { 
   		if (!(t1.GetType() == typeof(NumberTerm)) {
            /*CAMBIAR: No se puede usar throw en c#
            throw new ParseException(getSourceRef(t1)+" ArithFactor: first operand '"+t1+"' is not numeric or variable.");*/
        }
                                  
        if (!(t2.GetType() == typeof(NumberTerm)) {
            /*CAMBIAR: No se puede usar throw en c#
            throw new ParseException(getSourceRef(t2)+" ArithFactor: second operand '"+t2+"' is not numeric or variable.");*/
        }
        return new ArithExpr((NumberTerm)t1, op, (NumberTerm)t2);
    }
]  { return t1; }
}


Object arithm_expr_simple():
                                { Token K; object t; VarTerm v; }
{
 ( K = <NUMBER>                 { NumberTerm ni = ASSyntax.ParseNumber(K.image);
                                  ni.SetSrcInfo(new SourceInfo(asSource, K.beginLine));
                                  return ni;
                                }
 | "-" t = arithm_expr_simple() 
 { 
 	if (!(t.GetType() == typeof(NumberTerm)) {
        /*CAMBIAR: No se puede usar throw en c#
        throw new ParseException(getSourceRef(t)+" The argument '"+t+"' of operator '-' is not numeric or variable.");*/
    }
    return new ArithExpr(ArithmeticOp.minus, (NumberTerm)t);
 }
 | "+" t = arithm_expr_simple() 
 { 
 	if (!(t.GetType() == typeof(NumberTerm)) {
        /*CAMBIAR: No se puede usar throw en c#
        throw new ParseException(getSourceRef(t)+" The argument '"+t+"' of operator '+' is not numeric or variable.");*/
    }
    return new ArithExpr(ArithmeticOp.plus, (NumberTerm)t);
 }

 | "(" t = log_expr() ")"       { return t; }
 | t = function()               { return t; }
 )
}

Term function():          { Literal l; }
{
   l = literal()
   { ArithFunction af = GetArithFunction(l);
        if (af == null) {
            return l;
        } 
        else {
           ArithFunctionTerm at = new ArithFunctionTerm(af);
           at.SetSrcInfo(l.GetSrcInfo());
           at.SetTerms(l.GetTerms());
           at.SetAgent(curAg);
           return at;
        }
    }
}

//AQUI
VarTerm var(Atom ns):      { Token K; VarTerm v; ListTerm lt = null; }
{
 ( K = <VAR>          { v = new VarTerm(ns, K.image); v.SetSrcInfo(new SourceInfo(asSource, K.beginLine));}
 | K = <UNNAMEDVARID> { Matcher matcher = patternUnnamedWithId.matcher(K.image);
                        if (matcher.find()) {
                            v = UnnamedVar.Create(ns, Integer.ParseInt(matcher.group(1)), K.image);
                        } else {
        	                v = UnnamedVar.Create(ns, K.image);
                        }
                      }
 | K = <UNNAMEDVAR>   { v = UnnamedVar.Create(ns, K.image); }
 )
 [
   lt = list()      { v.SetAnnots(lt); }
 ]
                    { return v;
                    }
}

StringTerm string():{ Token k; StringTermImpl s; }
{
  k = <STRING>      { s = new StringTermImpl(k.image.substring(1,k.image.length()-1).ReplaceAll("\\\\n", "\n").ReplaceAll("\\\\\"","\"") );
                      s.SetSrcInfo(new SourceInfo(asSource,k.beginLine));
                      return s;
                    }
}
